<!doctype html>
<html>
	<head>
		<meta charset="UTF-8" />
		<title>Canvas Drag and Drop Test</title>
	</head>
	<body>
	
	<a href="#" id="generator">Generator</a>
	<a href="#" id="trans">Trans</a>
	<section>
		<div>
			<canvas id="canvas" width="1000" height="1000">
				This text is displayed if your browser does not support HTML5 Canvas.
			</canvas>
			
<script type="text/javascript">
	var WIDTH = 1000;
	var HEIGHT = 1000;
	var canvas = document.getElementById("canvas");
	var ctx = canvas.getContext("2d");
	
	ctx.fillStyle = "#FAF7F8";
	rect(0,0,WIDTH,HEIGHT);
	
	function rect(x,y,w,h) {
		ctx.beginPath();
		ctx.rect(x,y,w,h);
		ctx.closePath();
		ctx.fill();
	}
	

	BaseElement = function(){
		
	}
	
	
	Generator = function(){
		this.colorStroke = '#444444';
		this.width = 50;
		this.height = 50;
		this.radiusConnector = 5;
		this.indexShowConnector = null;
		this.x = 5;
		this.y = 5;
		this.connectors = new Array(
			{"x" : this.x + this.width/2, "y" : this.y + this.width }
		)
		
		this.move = function(dx, dy){
			this.x += dx;
			this.y += dy;
			for (var i in this.connectors){
				this.connectors[i].x +=dx;
				this.connectors[i].y +=dy;
			}
			console.log(this.connectors);
		}
		
		this.draw = function(){
			var r = this.width/2;
			var x0 = this.width/2 + this.x;
			var y0 = this.height/2 + this.y;
			
			ctx.strokeStyle = this.colorStroke;
			
			ctx.beginPath();
			ctx.arc(x0, y0 ,r , 0 , 2 * Math.PI, false);
			ctx.closePath();
			ctx.stroke();
			
			ctx.moveTo(x0,y0);
			ctx.arc(x0 - r/4, y0, r/4, 0 ,  Math.PI, true);
			ctx.stroke();
			
			ctx.moveTo(x0,y0);
			ctx.arc(x0 + r/4, y0,r/4, Math.PI ,0  , true);
			ctx.stroke();
			
			if (this.indexShowConnector != null){
				ctx.fillStyle = "#FF0000";
				ctx.beginPath();
				ctx.arc(this.connectors[this.indexShowConnector].x, 
						this.connectors[this.indexShowConnector].y,
						this.radiusConnector, 0,  2*Math.PI, true );
				ctx.closePath();
				ctx.fill();
			}
			
		}
		
		this.isPointInsideElement = function(x, y){
			if(Math.pow(x - (this.x + this.width/2),2) + Math.pow(y - (this.y + this.height/2), 2) < Math.pow(this.width/2,2)) return true;
			return false;
		}
		
		this.isPointInAreaConnector = function(x,y){
			for (var j in this.connectors){
				if (Math.pow(x - this.connectors[j].x,2) + Math.pow(y - this.connectors[j].y,2)<Math.pow(this.radiusConnector,2)){
					this.indexShowConnector = j;
					return j;
				}
			}
			return false;
		}
		
	}
	
	
	Transformator = function(){
		this.colorStroke = '#444444';
		this.width = 50;
		this.height = 75;
		this.radiusConnector = 5;
		this.lengthConnection = 15;
		this.indexShowConnector = null;
		this.x = 20;
		this.y = 20;
		this.connectors = new Array(
				{"x" : this.x + this.width/2, "y" : this.y},
				{"x" : this.x + this.width/2, "y" : this.y + this.width*1.5+2*this.lengthConnection}
			);
		
		this.move = function(dx, dy){
			this.x += dx;
			this.y += dy;
			for (var i in this.connectors){
				this.connectors[i].x +=dx;
				this.connectors[i].y +=dy;
			}
			console.log(this.connectors);
		}
		

		
		this.draw = function(){
			var r = this.width/2;
			var x0 = this.width/2 + this.x;
			var y0 = this.width/2 + this.y;
			
			ctx.strokeStyle = this.colorStroke;
			
			ctx.beginPath();
			
			ctx.moveTo(this.width/2 + this.x, this.y);
			ctx.lineTo(this.width/2 + this.x,  this.lengthConnection  + this.y);
			
			ctx.arc(x0, y0 + this.lengthConnection ,r , 1.5*Math.PI , -0.5 * Math.PI, true);
			
			ctx.moveTo(x0, this.lengthConnection + 3*r + this.y);
			ctx.lineTo(x0, 2*this.lengthConnection + 3*r + this.y);
			
			ctx.arc(x0, y0 + this.lengthConnection + r ,r , 0.5*Math.PI , -1.5 * Math.PI, true);

			
			ctx.closePath();
			ctx.stroke();
			
			
			
			if (this.indexShowConnector != null){
				ctx.fillStyle = "#FF0000";
				ctx.beginPath();
				ctx.arc(this.connectors[this.indexShowConnector].x, 
						this.connectors[this.indexShowConnector].y,
						this.radiusConnector, 0,  2*Math.PI, true );
				ctx.closePath();
				ctx.fill();
			}
			
		}
		
		this.isPointInsideElement = function(x, y){
			if(Math.pow(x - (this.x + this.width/2),2) + Math.pow(y - (this.y + this.width/2), 2) < Math.pow(this.width/2,2)) return true;
			if(Math.pow(x - (this.x + this.width/2),2) + Math.pow(y - (this.y + 1.5*this.width), 2) < Math.pow(this.width/2,2)) return true;
			return false;
		}
		
		this.isPointInAreaConnector = function(x,y){
			for (var j in this.connectors){
				if (Math.pow(x - this.connectors[j].x,2) + Math.pow(y - this.connectors[j].y,2)<Math.pow(this.radiusConnector,2)){
					this.indexShowConnector = j;
					return j;
				}
			}
			return false;
		}
	
	}
	var generator1 = new Generator();
	var generator2 = new Generator();
	var generator3 = new Generator();
	var transformator1 = new Transformator();
	var transformator2 = new Transformator();
		

	
	ManagerField = function(canvas){
		this.ctx = ctx;
		this.indexCatchElement = null;
		this.fieldSelect = null;
		this.drawingLine = null;
		

		this.catchingFirstConnector = null;
		this.catchingSecondConnector = null;
		
		this.colorStrokeDisselect = "#444444";
		this.colorStrokeSelect = "#F40B28";
		this.prevX = null;
		this.prevY = null;
		this.width = 1000;
		this.height = 1000;
		var elements = [];
		var connections = [];
		var canvas = canvas;
		var self = this;
		
		
		
		
		this.chooseModeMove = function(e){
			console.log("chooseModeMove");
			var x = e.pageX-canvas.offsetLeft;
			var y = e.pageY - canvas.offsetTop;
			
			if (self.catchingFirstConnector != null){
				console.log("OEEE")
				self.drawingLine = {};
				self.drawingLine.beginX = x;
				self.drawingLine.beginY = y;
				self.drawingLine.endX = x;
				self.drawingLine.endY = y;
				canvas.onmousemove = self.moveDrawingLine;
				console.log(self.drawingLine);
				return false;
			}
			
			/*Catch element if mouse get in its area*/
			for (var j in elements){
				if (elements[j].isPointInsideElement(x,y) == true){
					self.indexCatchElement = j;
					elements[j].colorStroke = self.colorStrokeSelect;
					self.prevX = x;
					self.prevY = y;
					canvas.onmousemove = self.moveCatchElement;
					console.log("Choose element with index: " + j);
					break;
				}
			}
			
			/*If mouse doesn't get area of element then create area for select*/
			if (self.indexCatchElement == null){
				self.fieldSelect = {};
				self.fieldSelect.beginX = x;
				self.fieldSelect.beginY = y;
				self.fieldSelect.endX = x;
				self.fieldSelect.endY = y;
				canvas.onmousemove = self.moveFieldSelect;
				console.log("Choose mode : Create area for select ");
				console.log(self.fieldSelect);
			}
			
			self.redrawCanvas();
			console.log("-------END chooseModeMove------")
		}
		
		this.rectangle = function(x,y,w,h){
			this.ctx.beginPath();
			this.ctx.rect(x,y,w,h);
			this.ctx.closePath();
		}
		
		this.line = function(x1,y1,x2,y2){
			this.ctx.beginPath();
			this.ctx.strokeStyle = 'red';
			this.ctx.moveTo(x1,y1);
			this.ctx.lineTo(x2,y2);
			this.ctx.stroke();
		}
		
		this.clearCanvas = function(){
			this.ctx.clearRect(0, 0, this.width, this.height);
			this.ctx.fillStyle = "#FAF7F8";
			this.rectangle(0, 0, this.width, this.height);
			this.ctx.fill();
		}
		

		
		
		
		this.redrawCanvas = function(){
			this.clearCanvas();
			
			/*Drawing all elements*/
			for (var j in elements){
				elements[j].draw();
			}
			
			/*Drawing area for select*/
			if (self.fieldSelect != null){
				console.log("Draw area fore select");
				console.log(self.fieldSelect.beginX + " " + self.fieldSelect.beginY + " " );
				this.ctx.fillStyle = "#444444";
				this.rectangle(self.fieldSelect.beginX,
							   self.fieldSelect.beginY,
							   self.fieldSelect.endX-self.fieldSelect.beginX,
							   self.fieldSelect.endY-self.fieldSelect.beginY);
				this.ctx.stroke();
			}
			
			/*Drawing path for future connection*/
			if (self.drawingLine != null){
				console.log("drawing LINE");
				self.line(self.drawingLine.beginX, self.drawingLine.beginY,
						  self.drawingLine.endX, self.drawingLine.endY);
			}
			
			/*Drawing fixing connecton
				connections: { 
					{"first":"valueConnector", "second":"valueConnector"},
					....
					{"first":"valueConnector", "second":"valueConnector"},
				}
				valueConnector:{
					"indexElement"   : "value",
					"indexConnector" : "value"
				}
			*/
			for (var j in connections){
				var firstElement = elements[connections[j].first.indexElement];
				var secondElement = elements[connections[j].second.indexElement];
				var first = firstElement.connectors[connections[j].first.indexConnector];
				var second = secondElement.connectors[connections[j].second.indexConnector];
				
				if (firstElement.y < secondElement.y){
					var temporarily1 = firstElement;
					firstElement = secondElement;
					secondElement = temporarily1;
					
					var temporarily2 = first;
					first = second;
					second = temporarily2;
				}
				
				console.log(connections);
				console.log("Attention");
				
				if (firstElement.y == first.y){
					if (secondElement.y == second.y){
						this.line(first.x, first.y, first.x, second.y);
						this.line(first.x, second.y, second.x, second.y);
					} else{
						var middleX = first.x + (second.x - first.x)/2;
						this.line(first.x, first.y, middleX, first.y);
						this.line(middleX, first.y, middleX, second.y);
						this.line(middleX, second.y, second.x, second.y)
					}
				} else{
					if (secondElement.y == second.y){
						var middleX = first.x + (second.x - first.x)/2;
						this.line(first.x, first.y, middleX, first.y);
						this.line(middleX, first.y, middleX, second.y);
						this.line(middleX, second.y, second.x, second.y)
					} else{

						this.line(first.x, first.y, first.x, second.y);
						this.line(first.x, second.y, second.x, second.y);
					}
				}
				
				/*
					if (secondElement.y == second.y){
						console.log("01")
						var middleX = first.x + (second.x - first.x)/2;
						this.line(first.x, first.y, middleX, first.y);
						this.line(middleX, first.y, middleX, second.y);
						this.line(middleX, second.y, second.x, second.y)
					} else {
						this.line(first.x, first.y, second.x, first.y);
						this.line(second.x, first.y, second.x, second.y);
					}
				
				
				/*if (second.y > secondElement.y){
					if (first.y > firstElement.y){
						console.log("01")
						this.line(first.x, first.y, second.x, first.y);
						this.line(second.x, first.y, second.x, second.y);
					} else {
						console.log("02")
						this.line(first.x, first.y, first.x, second.y);
						this.line(first.x, second.y, second.x, second.y);
					}
				} else {
					console.log("03")
					this.line(first.x, first.y, first.x, second.y);
					this.line(first.x, second.y, second.x, second.y)
				}
				/*if (first.y < secondElement.y){
					this.line(first.x, first.y, first.x, second.y);
					this.line(first.x, second.y, second.x, second.y)
				} else{
					this.line(first.x, first.y, first.x + (second.x-first.x)/2, first.y);
					this.line(first.x + (second.x-first.x)/2, first.y, first.x + (second.x-first.x)/2,second.y);
					this.line(first.x + (second.x-first.x)/2, second.y, second.x, second.y)
				}*/
				
				console.log("Fix connection:")
				console.log(first);
				console.log(second)
				console.log("------")
			}
		}
		

		
		
		this.clearAfterClickMouse = function(e){
			
			if (self.indexCatchElement != null){
				elements[self.indexCatchElement].colorStroke = self.colorStrokeDisselect;
				self.indexCatchElement = null;
				canvas.onmousemove = self.trackingConnectors;
			} 
			
			if (self.fieldSelect != null){
				self.fieldSelect = null;
				canvas.onmousemove = self.trackingConnectors;
			}
			
			if (self.drawingLine != null){
				if ((self.catchingFirstConnector!=null) && (self.catchingSecondConnector!=null)){
					console.log("create new connection");
					self.createNewConnection(self.catchingFirstConnector, self.catchingSecondConnector)
				}
				self.drawingLine = null;
				elements[self.catchingFirstConnector.indexElement].indexShowConnector = null;
				self.catchingFirstConnector = null;
				canvas.onmousemove = self.trackingConnectors;
				console.log(self.indexElementCatchingFirstConnector + " " +self.indexElementCatchingSecondConnector);
				
			}
			
			self.redrawCanvas();
		}
		
		this.moveCatchElement = function(e){
			console.log("moveCatchElement");
			var currentX = e.pageX - canvas.offsetLeft;
			var currentY = e.pageY - canvas.offsetTop;
			
			if (elements[self.indexCatchElement] !=null){
				elements[self.indexCatchElement].move(currentX - self.prevX, currentY - self.prevY);
				self.prevX = currentX;
				self.prevY = currentY;
			}
			self.redrawCanvas();
		}
		
		this.moveFieldSelect = function(e){
			console.log("moveFieldSelect");
			var currentX = e.pageX - canvas.offsetLeft;
			var currentY = e.pageY - canvas.offsetTop;
			
			if (self.fieldSelect != null){
				self.fieldSelect.endX = currentX;
				self.fieldSelect.endY = currentY;
			}
			self.redrawCanvas();
		}
		
		this.moveDrawingLine = function(e){
			console.log("moveDrawingLine");
			var currentX = e.pageX - canvas.offsetLeft;
			var currentY = e.pageY - canvas.offsetTop;
			
			if (self.drawingLine != null){
				self.drawingLine.endX = currentX;
				self.drawingLine.endY = currentY;
			}
			
			self.catchingSecondConnector = null;
			console.log(elements)
			for (var i in elements){
				console.log("i=" + i)
				if (i != self.catchingFirstConnector.indexElement){
					elements[i].indexShowConnector = null;
					if (elements[i].isPointInAreaConnector(currentX,currentY) !== false){
						var connector = {};
						connector.indexElement = i;
						connector.indexConnector = elements[i].isPointInAreaConnector(currentX,currentY);
						self.catchingSecondConnector = connector;
						console.log("secondConnector: ");
						console.log(self.catchingSecondConnector);
						console.log("----------")
					}
				}	
			}
			self.redrawCanvas();
		}
		
		
		/* firstConnector: {"indexElement":"value", "indexConnector":"value"}*/
		this.createNewConnection = function(firstConnector, secondConnector){
			var connection = {};
			connection.first = firstConnector;
			connection.second = secondConnector;
			connections.push(connection);
			console.log("Connection:")
			console.log(connections);
		}

		
		this.trackingConnectors = function(e){
			/*console.log("trackingConnectors");*/
			var currentX = e.pageX - canvas.offsetLeft;
			var currentY = e.pageY - canvas.offsetTop;
			
			self.catchingFirstConnector = null;
			for (var i in elements){
				elements[i].indexShowConnector = null;
				if (elements[i].isPointInAreaConnector(currentX,currentY) !== false){
					var connector = {};
					connector.indexElement = i;
					connector.indexConnector = elements[i].isPointInAreaConnector(currentX,currentY); 
					self.catchingFirstConnector = connector;
					/*console.log("catchingFirstConnector: " + self.catchingFirstConnector);*/
				}
			}
			self.redrawCanvas();
		}
		
		
		this.createElement = function(element){
			elements.push(element);
			element.draw();
			console.log(elements);
		}
		
		/*Add handle for events*/
		canvas.onmousedown = self.chooseModeMove;
		canvas.onmouseup   = self.clearAfterClickMouse;
		canvas.onmousemove = self.trackingConnectors;
		
	}
	var managerField = new ManagerField(canvas);
	
	/*managerField.createElement(transformator1);
	managerField.createElement(transformator2);*/
	
	
	document.getElementById('generator').onclick = createGenerator;
	document.getElementById('trans').onclick = createTrans;

	
	function createGenerator(e){
		var generator = new Generator();
		managerField.createElement(generator);
		return false;
	}
	function createTrans(e){
		var trans = new Transformator();
		managerField.createElement(trans);
		return false;
	}
	
	
	

</script>
			
			
			
			
		</div>
	</section>
	</body>
</html>
<script>
	


</script>